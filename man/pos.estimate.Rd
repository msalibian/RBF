% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RBF-fn.R
\name{pos.estimate}
\alias{pos.estimate}
\title{#' Cross-validation for Robust Backfitting
#'
#' This function performs one run of K-fold cross-validation using the
#' robust backfitting algorithm.
#'
#' This function performs one run of K-fold cross-validation using the
#' robust backfitting algorithm and returns a robust measure of the
#' hold out prediction error.
#'
#' @param k a positive integer indicating the number of folds.
#' @param Xp a matrix (n x p) containing the explanatory variables
#' @param yp vector of responses (missing values are allowed)
#' @param windows vector of bandwidths for the local polynomial smoother,
#' one per explanatory variable.
#' @param epsilon convergence criterion. Maximum allowed relative difference between
#' consecutive estimates
#' @param degree degree of the local polynomial smoother. Defaults to \code{0} (local constant).
#' @param seed an integer used to set the seed of the pseudo-number generator that
#' creates the \code{k} folds.
#' @param max.it Maximum number of iterations for the algorithm.
#' @param k.h tuning constant for a Huber-type loss function.
#' @param k.t tuning constant for a Tukey-type loss function.
#' @param type one of either \code{'Tukey'} or \code{'Huber'}.
#'
#' @return A real number with a robust measure of (hold-out) prediction error
#'
#' @author Matias Salibian-Barrera, \email{matias@stat.ubc.ca}, Alejandra Martinez
#'
#' @examples
#' data(airquality)
#' x <- airquality
#' x <- x[complete.cases(x), c('Ozone', 'Solar.R', 'Wind', 'Temp')]
#' y <- as.vector(x$Ozone)
#' x <- as.matrix(x[, c('Solar.R', 'Wind', 'Temp')])
#' backf.rob.cv(k=5, Xp = x, yp=y, windows=c(136.7, 8.9, 4.8), type='Tukey', degree=1)
#'
#' @export
backf.rob.cv <- function(k=5, Xp, yp, windows, epsilon=1e-6, degree, type='Tukey', k.h=1.345,
                         k.t = 4.685, seed=123, max.it=50) {
  # does k-fold CV and returns "robust mean-squared prediction error"
  n <- length(yp)
  # k1 <- floor(n/k)
  # ids <- rep(1:k, each=k1)
  # if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
  # save existing random seed
  if(exists(".Random.seed", where=.GlobalEnv)) old.seed <- .Random.seed
  set.seed(seed)
  ids <- sample( (1:n) %% k + 1 )
  Xp <- as.matrix(Xp)
  preds <- rep(NA, n)
  for(j in 1:k) {
    XX <- Xp[ids!=j, , drop=FALSE]
    yy <- yp[ids!=j]
    tmp <- try( backf.rob(yy ~ XX, point=Xp[ids==j,, drop=FALSE], windows=windows, epsilon=epsilon, degree=degree, type=type, max.it=max.it, k.h=k.h, k.t=k.t) )
      #try( backf.rob(Xp=XX, yp=yy, point=Xp[ids==j,, drop=FALSE], windows=windows, epsilon=epsilon, degree=degree, type=type, max.it=max.it, k.h=k.h, k.t=k.t) )
    if( class(tmp)[1] != 'try-error') {
      preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
    }
  }
  # restore seed existing before call
  if(exists('old.seed')) assign('.Random.seed', old.seed, envir=.GlobalEnv)
  return( mad( (preds-yp), na.rm=TRUE )^2 + median( (preds-yp)^2, na.rm=TRUE ) )
}}
\usage{
pos.estimate(y, ini = NULL, sigma.hat, epsilon = 1e-06,
  iter.max = 10, typePhi)
}
\description{
#' Cross-validation for the Classical Backfitting algorithm
#'
#' This function performs one run of K-fold cross-validation using the
#' classical backfitting algorithm.
#'
#' This function performs one run of K-fold cross-validation using the
#' classical backfitting algorithm and returns the mean squared
#' hold out prediction error.
#'
#' @param k a positive integer indicating the number of folds.
#' @param Xp a matrix (n x p) containing the explanatory variables
#' @param yp vector of responses (missing values are allowed)
#' @param windows vector of bandwidths for the local polynomial smoother,
#' one per explanatory variable.
#' @param epsilon convergence criterion. Maximum allowed relative difference between
#' consecutive estimates
#' @param degree degree of the local polynomial smoother. Defaults to \code{0} (local constant).
#' @param seed an integer used to set the seed of the pseudo-number generator that
#' creates the \code{k} folds.
#' @param max.it Maximum number of iterations for the algorithm.
#'
#' @return A real number with the mean squared (hold-out) prediction error
#'
#' @author Matias Salibian-Barrera, \email{matias@stat.ubc.ca}, Alejandra Martinez
#'
#' @examples
#' data(airquality)
#' x <- airquality
#' x <- x[complete.cases(x), c('Ozone', 'Solar.R', 'Wind', 'Temp')]
#' y <- as.vector(x$Ozone)
#' x <- as.matrix(x[, c('Solar.R', 'Wind', 'Temp')])
#' backf.l2.cv(k=5, Xp = x, yp=y, windows=c(130, 9, 10), degree=1)
#'
#' @export
backf.l2.cv <- function(k=5, Xp, yp, windows, epsilon=1e-6,
                        degree, seed=123, max.it=50) {
  # does k-fold CV and returns mean-squared prediction error
  n <- length(yp)
  # k1 <- floor(n/k)
  # ids <- rep(1:k, each=k1)
  # if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
  # save existing random seed
  if(exists(".Random.seed", where=.GlobalEnv)) old.seed <- .Random.seed
  set.seed(seed)
  ids <- sample( (1:n) %% k + 1 )
  Xp <- as.matrix(Xp)
  preds <- rep(NA, n)
  for(j in 1:k) {
    XX <- Xp[ids!=j, , drop=FALSE]
    yy <- yp[ids!=j]
    tmp <- try( backf.cl(yy ~ XX, point=Xp[ids==j, , drop=FALSE], windows=windows, epsilon=epsilon, degree=degree, max.it=max.it) )
      #try( backf.cl(Xp=XX, yp=yy, point=Xp[ids==j, , drop=FALSE], windows=windows, epsilon=epsilon, degree=degree, max.it=max.it) )
    if( class(tmp)[1] != 'try-error') {
      preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
    }
  }
  # restore seed existing before call
  if(exists('old.seed')) assign('.Random.seed', old.seed, envir=.GlobalEnv)
  return( mean( (preds-yp)^2, na.rm=TRUE ) )
}
}
