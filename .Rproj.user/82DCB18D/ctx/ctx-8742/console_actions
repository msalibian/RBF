{
    "type": [
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        3,
        3,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        3,
        2,
        2,
        3,
        3,
        3,
        3,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        3,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        2,
        2,
        3,
        3,
        3,
        3,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        3,
        3,
        0,
        1,
        3,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        2,
        2,
        3,
        3,
        3,
        3,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        2,
        3,
        3,
        3,
        0,
        1,
        3,
        0,
        1,
        3,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2
    ],
    "data": [
        "> ",
        "ccs <- complete.cases(datos)",
        "> ",
        "X <- as.matrix( datos[ccs, c('Income', 'Edu')] )",
        "> ",
        "y <- as.vector( datos[ccs, 'Overall'] )",
        "> ",
        "#Load packages",
        "> ",
        "library(RBF)",
        "> ",
        "library(RobStatTM)",
        "> ",
        "# Scatter plot",
        "> ",
        "pairs(cbind(y, X))",
        "> ",
        "# Classical fit",
        "> ",
        "# Bandwidth selection with leave-one-out cross-validation",
        "> ",
        "a <- c(0.5, 1, 1.5, 2)",
        "> ",
        "h1 <- a * sd(X[,1])",
        "> ",
        "h2 <- a * sd(X[,2])",
        "> ",
        "hh <- expand.grid(h1, h2)",
        "> ",
        "nh <- nrow(hh)",
        "> ",
        "rmspe <- rep(NA, nh)",
        "> ",
        "jbest <- 0",
        "> ",
        "cvbest <- +Inf",
        "> ",
        "# leave-one-out",
        "> ",
        "n <- nrow(X)",
        "> ",
        "system.time({",
        "+ ",
        "  for(i in 1:nh) {",
        "+ ",
        "    # leave-one-out CV loop",
        "+ ",
        "    print(hh[i,])",
        "+ ",
        "    preds <- rep(NA, n)",
        "+ ",
        "    for(j in 1:n) {",
        "+ ",
        "      print(j)",
        "+ ",
        "      tmp <- try( backf.cl(y ~ X, point = X[j, ],",
        "+ ",
        "                            windows = hh[i, ], epsilon = 1e-06, max.it = 100,",
        "+ ",
        "                            subset = c(-j) ))",
        "+ ",
        "      if (class(tmp)[1] != \"try-error\") {",
        "+ ",
        "        preds[j] <- rowSums(tmp$prediction) + tmp$alpha",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    pred.res <- preds - y",
        "+ ",
        "    print(sum(is.na(pred.res)))",
        "+ ",
        "    ",
        "+ ",
        "    if(sum(!is.na(pred.res))>0){",
        "+ ",
        "      rmspe[i] <- mean(pred.res^2)",
        "+ ",
        "      if( rmspe[i] < cvbest ) {",
        "+ ",
        "        jbest <- i",
        "+ ",
        "        cvbest <- rmspe[i]",
        "+ ",
        "        print('Record')",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    print(c(i, rmspe[i]))",
        "+ ",
        "  }",
        "+ ",
        "})",
        "        Var1       Var2\n1 0.05384702 0.05629671\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 43\n",
        "Error in if (rmspe[i] < cvbest) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "Timing stopped at: 4.099 0.001 4.079\n",
        "> ",
        "bandw <- hh[jbest,]",
        "> ",
        "rmspe[i] ",
        "[1] NaN\n",
        "> ",
        "# Classical fit",
        "> ",
        "# Bandwidth selection with leave-one-out cross-validation",
        "> ",
        "a <- c(0.5, 1, 1.5, 2)",
        "> ",
        "h1 <- a * sd(X[,1])",
        "> ",
        "h2 <- a * sd(X[,2])",
        "> ",
        "hh <- expand.grid(h1, h2)",
        "> ",
        "nh <- nrow(hh)",
        "> ",
        "rmspe <- rep(NA, nh)",
        "> ",
        "jbest <- 0",
        "> ",
        "cvbest <- +Inf",
        "> ",
        "# leave-one-out",
        "> ",
        "n <- nrow(X)",
        "> ",
        "system.time({",
        "+ ",
        "  for(i in 1:nh) {",
        "+ ",
        "    # leave-one-out CV loop",
        "+ ",
        "    print(hh[i,])",
        "+ ",
        "    preds <- rep(NA, n)",
        "+ ",
        "    for(j in 1:n) {",
        "+ ",
        "      print(j)",
        "+ ",
        "      tmp <- try( backf.cl(y ~ X, point = X[j, ],",
        "+ ",
        "                            windows = hh[i, ], epsilon = 1e-06, max.it = 100,",
        "+ ",
        "                            subset = c(-j) ))",
        "+ ",
        "      if (class(tmp)[1] != \"try-error\") {",
        "+ ",
        "        preds[j] <- rowSums(tmp$prediction) + tmp$alpha",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    pred.res <- preds - y",
        "+ ",
        "    print(sum(is.na(pred.res)))",
        "+ ",
        "    ",
        "+ ",
        "    if(sum(!is.na(pred.res))>0){",
        "+ ",
        "      rmspe[i] <- mean(pred.res^2, na.rm=TRUE)",
        "+ ",
        "      if( rmspe[i] < cvbest ) {",
        "+ ",
        "        jbest <- i",
        "+ ",
        "        cvbest <- rmspe[i]",
        "+ ",
        "        print('Record')",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    print(c(i, rmspe[i]))",
        "+ ",
        "  }",
        "+ ",
        "})",
        "        Var1       Var2\n1 0.05384702 0.05629671\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 43\n[1] \"Record\"\n[1]     1.00 13051.09\n      Var1       Var2\n2 0.107694 0.05629671\n[1] 1\n[1] 2\n[1] 3\n[1] 4",
        "\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 43\n[1]     2.00 15130.37\n       Var1       Var2\n3 0.1615411 0.05629671\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1]",
        " 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 39\n[1]     3.00 19979.56\n       Var1       Var2\n4 0.2153881 0.05629671\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1]",
        " 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 38\n[1]     4.0 22810.4\n        Var1      Var2\n5 0.05384702 0.1125934\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1]",
        " 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 40\n[1]     5.00 13882.09\n      Var1      Var2\n6 0.107694 0.1125934\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 37",
        "\n[1]     6.00 18624.97\n       Var1      Var2\n7 0.1615411 0.1125934\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 25\n[1]     7.00 25732.87\n       Var1      Var2\n8 0.2153881 0.1125934\n[1] 1\n[1] 2\n[1] 3",
        "\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 23\n[1]     8.00 28758.95\n        Var1      Var2\n9 0.05384702 0.1688901\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1]",
        " 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 39\n[1] \"Record\"\n[1]     9.00 12480.02\n       Var1      Var2\n10 0.107694 0.1688901\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26",
        "\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 33\n[1]    10.00 18402.18\n        Var1      Var2\n11 0.1615411 0.1688901\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38",
        "\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 16\n[1]    11.00 25704.16\n        Var1      Var2\n12 0.2153881 0.1688901\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50",
        "\n[1] 51\n[1] 52\n[1] 11\n[1]    12.00 30034.28\n         Var1      Var2\n13 0.05384702 0.2251868\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 38\n[1] \"Record\"\n[1]    13.0 11599.2\n       Var1      Var2\n14 0.107694",
        " 0.2251868\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 29\n[1]    14.00 17049.22\n        Var1      Var2\n15 0.1615411 0.2251868\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1]",
        " 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1] 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 10\n[1]    15.00 24387.32\n        Var1      Var2\n16 0.2153881 0.2251868\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n[1] 23\n[1]",
        " 24\n[1] 25\n[1] 26\n[1] 27\n[1] 28\n[1] 29\n[1] 30\n[1] 31\n[1] 32\n[1] 33\n[1] 34\n[1] 35\n[1] 36\n[1] 37\n[1] 38\n[1] 39\n[1] 40\n[1] 41\n[1] 42\n[1] 43\n[1] 44\n[1] 45\n[1] 46\n[1] 47\n[1] 48\n[1] 49\n[1] 50\n[1] 51\n[1] 52\n[1] 4\n[1]    16.00 28830.67\n   user  system elapsed \n 34.743   0.067  34.509 \n",
        "> ",
        "bandw <- hh[jbest,]",
        "> ",
        "bandw",
        "         Var1      Var2\n13 0.05384702 0.2251868\n",
        "> ",
        "# Fit",
        "> ",
        "cfit <- backf.cl(y ~ X, windows = bandw, degree = 1)",
        "Error in solve.default(t(tmp * we) %*% tmp, t(tmp) %*% (we * y.tilde.bis)) : \n  Lapack routine dgesv: system is exactly singular: U[2,2] = 0\n",
        "> ",
        "Xp <- X",
        "> ",
        "yp <- y",
        "> ",
        "  n <- length(yp)",
        "> ",
        "  Xp <- as.matrix(Xp)",
        "> ",
        "  q <- dim(Xp)[2]",
        "> ",
        "  corte <- 10*epsilon",
        "> ",
        "  corte.bis <- 10*epsilon",
        "> ",
        "  # Remove cases with missing responses",
        "> ",
        "  yp <- yp[ tmp <- (!is.na(yp)) ]",
        "> ",
        "  Xp <- Xp[tmp, , drop=FALSE]",
        "> ",
        "  n.miss <- length(yp)",
        "> ",
        "  if(is.null(prob)){",
        "+ ",
        "    prob <- rep(1,n.miss)",
        "+ ",
        "  } else {",
        "+ ",
        "    prob <- prob[tmp]",
        "+ ",
        "  }",
        "> ",
        "  alpha <- mean(yp)",
        "> ",
        "  # Start the backfitting algorithm.",
        "> ",
        "  g.matriz <- matrix(0,n.miss,q)",
        "> ",
        "  it <- 0",
        "> ",
        "  while( (corte > epsilon) & (it < max.it)) {",
        "+ ",
        "    g.matriz.aux <- g.matriz",
        "+ ",
        "    for(j in 1:q) {",
        "+ ",
        "      y.tilde.bis <- yp - alpha - rowSums(g.matriz[,-j,drop=FALSE])",
        "+ ",
        "      for(i in 1:n.miss) {",
        "+ ",
        "        we <- k.epan( (Xp[,j] - Xp[i,j]) / as.numeric(windows[j]) )",
        "+ ",
        "        if(degree == 0)",
        "+ ",
        "          g.matriz[i,j] <- sum( we * y.tilde.bis ) / sum( we )",
        "+ ",
        "        if(degree > 0) {",
        "+ ",
        "          tmp <- outer( as.vector( Xp[,j] - Xp[i,j]) , 1:degree, \"^\" )",
        "+ ",
        "          tmp <- cbind(rep(1,n.miss), tmp)",
        "+ ",
        "          g.matriz[i,j] <- solve( t(tmp * we) %*% tmp, t(tmp) %*% (we * y.tilde.bis))[1]",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    aux1 <- sum( colMeans(g.matriz) )",
        "+ ",
        "    g.matriz <- scale(g.matriz,center=TRUE,scale=FALSE)",
        "+ ",
        "    corte <- my.norm.2(rowSums(g.matriz.aux)-rowSums(g.matriz))",
        "+ ",
        "    it <- it + 1",
        "+ ",
        "  }",
        "> ",
        "  prediccion <- NULL",
        "> ",
        "  if(!is.null(point)){",
        "+ ",
        "    ",
        "+ ",
        "    #if(!is.matrix(point)) { #is.null(dim(point))) {",
        "+ ",
        "    #  prediccion <- mpunto <- as.matrix(point) # matrix(point, byrow=TRUE, ncol=length(point))",
        "+ ",
        "    #} else {",
        "+ ",
        "    #  prediccion <- mpunto <- point",
        "+ ",
        "    #}",
        "+ ",
        "    ",
        "+ ",
        "    if(is.null(dim(point))){",
        "+ ",
        "      if(q==1){",
        "+ ",
        "        prediccion <- mpunto <- as.matrix(point)",
        "+ ",
        "      }else{",
        "+ ",
        "        prediccion <- mpunto <- t(as.matrix(point))",
        "+ ",
        "      }",
        "+ ",
        "    } else {",
        "+ ",
        "      prediccion <- mpunto <- point",
        "+ ",
        "    }",
        "+ ",
        "    ",
        "+ ",
        "    np <- dim(mpunto)[1]",
        "+ ",
        "    for(k in 1:np){",
        "+ ",
        "      for(j in 1:q){",
        "+ ",
        "        y.tilde.bis <- yp - alpha - rowSums(g.matriz[,-j,drop=FALSE]) #- aux1",
        "+ ",
        "        we <- k.epan( (Xp[,j] - mpunto[k,j]) / windows[j] )",
        "+ ",
        "        if(degree == 0)",
        "+ ",
        "          prediccion[k,j] <- sum( we * y.tilde.bis ) / sum( we )",
        "+ ",
        "        if(degree > 0) {",
        "+ ",
        "          tmp <- outer( as.vector( Xp[,j] - mpunto[k,j]) , 1:degree, \"^\" )",
        "+ ",
        "          tmp <- cbind(rep(1,n.miss), tmp)",
        "+ ",
        "          prediccion[k,j] <- solve( t(tmp * we) %*% tmp, t(tmp) %*% (we * y.tilde.bis))[1]",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "  }",
        "Error: objeto 'point' no encontrado\n",
        "> ",
        "  object <- list(alpha=alpha, g.matrix=g.matriz, prediction=prediccion, Xp=Xp, yp=yp, formula=formula)",
        "> ",
        "  class(object) <- c(\"backf.cl\", \"backf\", \"list\")",
        "> ",
        "  return(object)",
        "Error: ninguna función desde donde volver, saltando a nivel superior\n",
        "> ",
        "# Fit",
        "> ",
        "cfit <- backf.cl(y ~ X, windows = bandw, degree = 1)",
        "Error in solve.default(t(tmp * we) %*% tmp, t(tmp) %*% (we * y.tilde.bis)) : \n  Lapack routine dgesv: system is exactly singular: U[2,2] = 0\n",
        "> ",
        "    g.matriz.aux <- g.matriz",
        "> ",
        "    for(j in 1:q) {",
        "+ ",
        "      y.tilde.bis <- yp - alpha - rowSums(g.matriz[,-j,drop=FALSE])",
        "+ ",
        "      for(i in 1:n.miss) {",
        "+ ",
        "        we <- k.epan( (Xp[,j] - Xp[i,j]) / as.numeric(windows[j]) )",
        "+ ",
        "        if(degree == 0)",
        "+ ",
        "          g.matriz[i,j] <- sum( we * y.tilde.bis ) / sum( we )",
        "+ ",
        "        if(degree > 0) {",
        "+ ",
        "          tmp <- outer( as.vector( Xp[,j] - Xp[i,j]) , 1:degree, \"^\" )",
        "+ ",
        "          tmp <- cbind(rep(1,n.miss), tmp)",
        "+ ",
        "          g.matriz[i,j] <- solve( t(tmp * we) %*% tmp, t(tmp) %*% (we * y.tilde.bis))[1]",
        "+ ",
        "        }",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "> ",
        "library(devtools)",
        "Loading required package: usethis\n",
        "> ",
        "install_github(\"msalibian/RBF\", force=TRUE)",
        "Downloading GitHub repo msalibian/RBF@master\n",
        "  \r   checking for file ‘/tmp/RtmppDcxiH/remotes3a3f1a11bc9c/msalibian-RBF-421ee71/DESCRIPTION’ ...\r  \r\u001B[32m✓\u001B[39m  \u001B[38;5;247mchecking for file ‘/tmp/RtmppDcxiH/remotes3a3f1a11bc9c/msalibian-RBF-421ee71/DESCRIPTION’\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mpreparing ‘RBF’:\u001B[39m\u001B[36m\u001B[39m\n   checking DESCRIPTION meta-information ...\r  \r\u001B[32m✓\u001B[39m  \u001B[38;5;247mchecking DESCRIPTION meta-information\u001B[39m\u001B[36m\u001B[39m\n\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mcleaning src\u001B[39m\u001B[36m\u001B[39m",
        "\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mchecking for LF line-endings in source and make files and shell scripts\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mchecking for empty or unneeded directories\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mbuilding ‘RBF_2.0.1.tar.gz’\u001B[39m\u001B[36m\u001B[39m\n\r  \r   \n\r",
        "Installing package into ‘/home/alejandra/R/x86_64-pc-linux-gnu-library/3.6’\n(as ‘lib’ is unspecified)\n",
        "* installing *source* package ‘RBF’ ...\n",
        "** using staged installation\n",
        "** libs\n",
        "gcc -std=gnu99 -I\"/usr/share/R/include\" -DNDEBUG     -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-jbaK_j/r-base-3.6.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c RBF-fn.c -o RBF-fn.o\ngcc -std=gnu99 -I\"/usr/share/R/include\" -DNDEBUG     -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-jbaK_j/r-base-3.6.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c init.c -o init.o\ngcc -std=gnu99 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o RBF.so RBF-fn.o init.o -L/usr/lib/R/lib -lR\n",
        "installing to /home/alejandra/R/x86_64-pc-linux-gnu-library/3.6/00LOCK-RBF/00new/RBF/libs\n",
        "** R\n",
        "** byte-compile and prepare package for lazy loading\n",
        "** help\n",
        "*** installing help indices\n",
        "** building package indices\n",
        "** testing if installed package can be loaded from temporary location\n",
        "** checking absolute paths in shared objects and dynamic libraries\n",
        "** testing if installed package can be loaded from final location\n",
        "** testing if installed package keeps a record of temporary installation path\n",
        "* DONE (RBF)\n",
        "> ",
        "library(RBF)",
        "> ",
        "# Upload the data",
        "> ",
        "datos <- read.csv(\"/home/alejandra/Dropbox/Paper de paquetes en R/JOSS/pisasci2006.csv\", header=TRUE)",
        "> ",
        "str(datos)",
        "'data.frame':\t65 obs. of  11 variables:\n $ Country : Factor w/ 65 levels \"Albania\",\"Argentina\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ Overall : int  NA 391 527 511 382 510 390 434 534 438 ...\n $ Issues  : int  NA 395 535 505 353 515 398 427 532 444 ...\n $ Explain : int  NA 386 520 516 412 503 390 444 531 432 ...\n $ Evidence: int  NA 385 531 505 344 516 378 417 542 440 ...\n $ Interest: int  NA 567 465 507 612 503 592 523 469 591 ...\n $ Support : int  NA 506 487 515 542 492 519 527 501 564 ...\n $ Income  : num  0.599 0.678 0.826 0.835 0.566 0.831 0.637 0.663 0.84 0.673",
        " ...\n $ Health  : num  0.886 0.868 0.965 0.944 0.78 0.935 0.818 0.829 0.951 0.923 ...\n $ Edu     : num  0.716 0.786 0.978 0.824 NA 0.868 0.646 0.778 0.902 0.764 ...\n $ HDI     : num  0.724 0.773 0.92 0.866 NA 0.877 0.695 0.753 0.897 0.78 ...\n",
        "> ",
        "# Complete cases",
        "> ",
        "ccs <- complete.cases(datos)",
        "> ",
        "X <- as.matrix( datos[ccs, c('Income', 'Edu')] )",
        "> ",
        "y <- as.vector( datos[ccs, 'Overall'] )",
        "> ",
        "#Load packages",
        "> ",
        "library(RobStatTM)",
        "> ",
        "library(RBF)",
        "> ",
        "# Scatter plot",
        "> ",
        "pairs(cbind(y, X))",
        "> ",
        "# Classical fit",
        "> ",
        "# Bandwidth selection with leave-one-out cross-validation",
        "> ",
        "a <- c(0.5, 1, 1.5, 2)",
        "> ",
        "h1 <- a * sd(X[,1])",
        "> ",
        "h2 <- a * sd(X[,2])",
        "> ",
        "hh <- expand.grid(h1, h2)",
        "> ",
        "nh <- nrow(hh)",
        "> ",
        "rmspe <- rep(NA, nh)",
        "> ",
        "jbest <- 0",
        "> ",
        "cvbest <- +Inf",
        "> ",
        "# leave-one-out",
        "> ",
        "n <- nrow(X)",
        "> ",
        "system.time({",
        "+ ",
        "  for(i in 1:nh) {",
        "+ ",
        "    # leave-one-out CV loop",
        "+ ",
        "    print(hh[i,])",
        "+ ",
        "    preds <- rep(NA, n)",
        "+ ",
        "    for(j in 1:n) {",
        "+ ",
        "      print(j)",
        "+ ",
        "      tmp <- try( backf.cl(y ~ X, point = X[j, ],",
        "+ ",
        "                            windows = hh[i, ], epsilon = 1e-06, max.it = 100,",
        "+ ",
        "                            subset = c(-j) ))",
        "+ ",
        "      if (class(tmp)[1] != \"try-error\") {",
        "+ ",
        "        preds[j] <- rowSums(tmp$prediction) + tmp$alpha",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    pred.res <- preds - y",
        "+ ",
        "    print(sum(is.na(pred.res)))",
        "+ ",
        "    ",
        "+ ",
        "    if(sum(!is.na(pred.res))>0){",
        "+ ",
        "      rmspe[i] <- mean(pred.res^2, na.rm=TRUE)",
        "+ ",
        "      if( rmspe[i] < cvbest ) {",
        "+ ",
        "        jbest <- i",
        "+ ",
        "        cvbest <- rmspe[i]",
        "+ ",
        "        print('Record')",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    print(c(i, rmspe[i]))",
        "+ ",
        "  }",
        "+ ",
        "})",
        "        Var1       Var2\n1 0.05384702 0.05629671\n[1] 1\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 2\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 3\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 4\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 5\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 6\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 7\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 8\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 9\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 10\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 11\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 12\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 13\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 14\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 15\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 16\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 17\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 18\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 19\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 20\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 21\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 22\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 23\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 24\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 25\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 26\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 27\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 28\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 29\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 30\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 31\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 32\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 33\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 34\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 35\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 36\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 37\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 38\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 39\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 40\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 41\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 42\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 43\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 44\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 45\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 46\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 47\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 48\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 49\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 50\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 51\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 52\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 52\n[1]  1 NA\n      Var1       Var2\n2 0.107694 0.05629671\n[1] 1\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 2\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 3\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 4\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 5\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 6\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 7\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 8\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 9\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 10\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 11\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 12\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 13\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 14\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 15\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 16\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 17\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 18\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 19\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 20\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 21\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 22\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 23\n",
        "\n",
        "Timing stopped at: 7.287 0.003 7.26\n",
        "> ",
        "jbest",
        "[1] 0\n",
        "> ",
        "jbest",
        "[1] 0\n",
        "> ",
        "# Upload the data",
        "> ",
        "datos <- read.csv(\"/home/alejandra/Dropbox/Paper de paquetes en R/JOSS/pisasci2006.csv\", header=TRUE)",
        "> ",
        "str(datos)",
        "'data.frame':\t65 obs. of  11 variables:\n $ Country : Factor w/ 65 levels \"Albania\",\"Argentina\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ Overall : int  NA 391 527 511 382 510 390 434 534 438 ...\n $ Issues  : int  NA 395 535 505 353 515 398 427 532 444 ...\n $ Explain : int  NA 386 520 516 412 503 390 444 531 432 ...\n $ Evidence: int  NA 385 531 505 344 516 378 417 542 440 ...\n $ Interest: int  NA 567 465 507 612 503 592 523 469 591 ...\n $ Support : int  NA 506 487 515 542 492 519 527 501 564 ...\n $ Income  : num  0.599 0.678 0.826 0.835 0.566 0.831 0.637 0.663 0.84 0.673",
        " ...\n $ Health  : num  0.886 0.868 0.965 0.944 0.78 0.935 0.818 0.829 0.951 0.923 ...\n $ Edu     : num  0.716 0.786 0.978 0.824 NA 0.868 0.646 0.778 0.902 0.764 ...\n $ HDI     : num  0.724 0.773 0.92 0.866 NA 0.877 0.695 0.753 0.897 0.78 ...\n",
        "> ",
        "# Complete cases",
        "> ",
        "ccs <- complete.cases(datos)",
        "> ",
        "X <- as.matrix( datos[ccs, c('Income', 'Edu')] )",
        "> ",
        "y <- as.vector( datos[ccs, 'Overall'] )",
        "> ",
        "#Load packages",
        "> ",
        "library(RobStatTM)",
        "> ",
        "install_github(\"msalibian/RBF\", force=TRUE)",
        "Downloading GitHub repo msalibian/RBF@master\n",
        "  \r   checking for file ‘/tmp/RtmppDcxiH/remotes3a3ff00701d/msalibian-RBF-421ee71/DESCRIPTION’ ...\r  \r\u001B[32m✓\u001B[39m  \u001B[38;5;247mchecking for file ‘/tmp/RtmppDcxiH/remotes3a3ff00701d/msalibian-RBF-421ee71/DESCRIPTION’\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mpreparing ‘RBF’:\u001B[39m\u001B[36m\u001B[39m\n   checking DESCRIPTION meta-information ...\r  \r\u001B[32m✓\u001B[39m  \u001B[38;5;247mchecking DESCRIPTION meta-information\u001B[39m\u001B[36m\u001B[39m\n\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mcleaning src\u001B[39m\u001B[36m\u001B[39m",
        "\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mchecking for LF line-endings in source and make files and shell scripts\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mchecking for empty or unneeded directories\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mbuilding ‘RBF_2.0.1.tar.gz’\u001B[39m\u001B[36m\u001B[39m\n\r  \r   \n\r",
        "Installing package into ‘/home/alejandra/R/x86_64-pc-linux-gnu-library/3.6’\n(as ‘lib’ is unspecified)\n",
        "* installing *source* package ‘RBF’ ...\n",
        "** using staged installation\n",
        "** libs\n",
        "gcc -std=gnu99 -I\"/usr/share/R/include\" -DNDEBUG     -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-jbaK_j/r-base-3.6.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c RBF-fn.c -o RBF-fn.o\ngcc -std=gnu99 -I\"/usr/share/R/include\" -DNDEBUG     -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-jbaK_j/r-base-3.6.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c init.c -o init.o\ngcc -std=gnu99 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o RBF.so RBF-fn.o init.o -L/usr/lib/R/lib -lR\n",
        "installing to /home/alejandra/R/x86_64-pc-linux-gnu-library/3.6/00LOCK-RBF/00new/RBF/libs\n",
        "** R\n",
        "** byte-compile and prepare package for lazy loading\n",
        "** help\n",
        "*** installing help indices\n",
        "** building package indices\n",
        "** testing if installed package can be loaded from temporary location\n",
        "** checking absolute paths in shared objects and dynamic libraries\n",
        "** testing if installed package can be loaded from final location\n",
        "** testing if installed package keeps a record of temporary installation path\n",
        "* DONE (RBF)\n",
        "> ",
        "library(RBF)",
        "Error in fetch(key) : \n  lazy-load database '/home/alejandra/R/x86_64-pc-linux-gnu-library/3.6/RBF/help/RBF.rdb' is corrupt\n",
        "Error in fetch(key) : \n  lazy-load database '/home/alejandra/R/x86_64-pc-linux-gnu-library/3.6/RBF/help/RBF.rdb' is corrupt\n",
        "> ",
        "backf.rob()",
        "Error in terms.formula(formula, data = data) : \n  argument is not a valid model\n",
        "> ",
        "backf.rob",
        "function (formula, data, subset, windows, point = NULL, epsilon = 1e-06, \n    degree = 0, sigma.hat = NULL, prob = NULL, max.it = 50, k.h = 1.345, \n    k.t = 4.685, type = \"Huber\") \n{\n    cl <- match.call()\n    mf <- match.call(expand.dots = FALSE)\n    m <- match(c(\"formula\", \"data\", \"subset\"), names(mf), 0)\n    mf <- mf[c(1, m)]\n    mf$drop.unused.levels <- TRUE\n    mf[[1]] <- as.name(\"model.frame\")\n    mf <- eval(mf, parent.frame())\n    mt <- attr(mf, \"terms\")\n    yp <- model.response(mf, \"numeric\")\n    Xp <- model.matrix(mt, mf, NULL)\n",
        "    if (all(Xp[, 1] == 1)) \n        Xp <- Xp[, -1]\n    Xp <- as.matrix(Xp)\n    n <- length(yp)\n    q <- dim(Xp)[2]\n    corte <- 10 * epsilon\n    corte.bis <- 10 * epsilon\n    yp <- yp[tmp <- !is.na(yp)]\n    XX <- Xp\n    Xp <- Xp[tmp, , drop = FALSE]\n    n.miss <- length(yp)\n    if (is.null(prob)) {\n        prob <- rep(1, n.miss)\n    }\n    else {\n        prob <- prob[tmp]\n    }\n    if (is.null(sigma.hat)) {\n        ab <- rep(0, n.miss)\n        for (i in 1:n.miss) {\n            xtildebis <- scale(Xp, center = Xp[i, ], scale = windows)\n",
        "            a <- matrix(as.numeric(abs(xtildebis) < 1), n.miss, \n                q)\n            a <- apply(a, 1, prod)\n            a[a == 0] <- NA\n            ab[i] <- median(a * yp, na.rm = TRUE)\n        }\n        sigma.hat <- mad(yp - ab)\n        if (sigma.hat < 1e-10) \n            sigma.hat <- 1e-10\n    }\n    alpha <- 0\n    g.matriz <- matrix(0, n.miss, q)\n    it <- 0\n    while ((corte > epsilon) & (it < max.it)) {\n        g.matriz.aux <- g.matriz\n        for (j in 1:q) {\n            y.tilde.bis <- yp - alpha - rowSums(g.matriz[, -j, \n",
        "                drop = FALSE])\n            if (any(is.na(y.tilde.bis))) {\n                it <- (max.it + 1)\n                (break)()\n            }\n            for (i in 1:n.miss) {\n                if (degree == 0) {\n                  if (type == \"Huber\") {\n                    mu.ini <- median(y.tilde.bis[abs(Xp[, j] - \n                      Xp[i, j]) < windows[j]])\n                    if (!is.na(mu.ini)) {\n                      g.matriz[i, j] <- .C(\"kernel_huber_pos\", \n                        as.double(Xp[i, j]), as.double(Xp[, j]), \n",
        "                        as.integer(n.miss), as.double(y.tilde.bis), \n                        as.double(mu.ini), as.double(windows[j]), \n                        as.double(epsilon), as.double(sigma.hat), \n                        as.double(prob), as.double(k.h), as.integer(max.it), \n                        salida = as.double(0), PACKAGE = \"RBF\")$salida\n                    }\n                    else {\n                      g.matriz[i, j] <- NA\n                    }\n                  }\n                  if (type == \"Tukey\") {\n",
        "                    mu.ini <- median(y.tilde.bis[abs(Xp[, j] - \n                      Xp[i, j]) < windows[j]])\n                    if (!is.na(mu.ini)) {\n                      g.matriz[i, j] <- .C(\"kernel_tukey_pos\", \n                        as.double(Xp[i, j]), as.double(as.matrix(Xp[, \n                          j])), as.integer(n.miss), as.double(y.tilde.bis), \n                        as.double(mu.ini), as.double(windows[j]), \n                        as.double(epsilon), as.double(sigma.hat), \n                        as.double(prob), as.double(k.t), as.integer(max.it), \n",
        "                        salida = as.double(0), PACKAGE = \"RBF\")$salida\n                    }\n                    else {\n                      g.matriz[i, j] <- NA\n                    }\n                  }\n                }\n                if (degree > 0) {\n                  tmp <- outer(as.vector(Xp[, j] - Xp[i, j]), \n                    1:degree, \"^\")\n                  tmp <- cbind(rep(1, n.miss), tmp)\n                  beta.ini <- rep(0, degree + 1)\n                  if (type == \"Huber\") {\n                    g.matriz[i, j] <- .C(\"kernel_huber_lin\", \n",
        "                      as.double(Xp[i, j]), as.double(Xp[, j]), \n                      as.integer(n.miss), as.double(y.tilde.bis), \n                      as.double(tmp), as.integer(degree), as.double(beta.ini), \n                      as.double(windows[j]), as.double(epsilon), \n                      as.double(sigma.hat), as.double(prob), \n                      as.double(k.h), as.integer(max.it), salida = as.double(rep(0, \n                        degree + 1)), PACKAGE = \"RBF\")$salida[1]\n                  }\n                  if (type == \"Tukey\") {\n",
        "                    beta.ini <- .C(\"kernel_huber_lin\", as.double(Xp[i, \n                      j]), as.double(Xp[, j]), as.integer(n.miss), \n                      as.double(y.tilde.bis), as.double(tmp), \n                      as.integer(degree), as.double(beta.ini), \n                      as.double(windows[j]), as.double(epsilon), \n                      as.double(sigma.hat), as.double(prob), \n                      as.double(k.h), as.integer(max.it), salida = as.double(rep(0, \n                        degree + 1)), PACKAGE = \"RBF\")$salida\n",
        "                    if (!any(is.na(beta.ini))) {\n                      g.matriz[i, j] <- .C(\"kernel_tukey_lin\", \n                        as.double(Xp[i, j]), as.double(Xp[, j]), \n                        as.integer(n.miss), as.double(y.tilde.bis), \n                        as.double(tmp), as.integer(degree), as.double(beta.ini), \n                        as.double(windows[j]), as.double(epsilon), \n                        as.double(sigma.hat), as.double(prob), \n                        as.double(k.t), as.integer(max.it), salida = as.double(rep(0, \n",
        "                          degree + 1)), PACKAGE = \"RBF\")$salida[1]\n                    }\n                    else {\n                      g.matriz[i, j] <- NA\n                    }\n                  }\n                }\n            }\n        }\n        aux1 <- sum(colMeans(g.matriz))\n        g.matriz <- scale(g.matriz, center = TRUE, scale = FALSE)\n        corte <- my.norm.2(rowSums(g.matriz.aux) - rowSums(g.matriz))\n        it <- it + 1\n        y.tilde.bis <- yp - rowSums(g.matriz)\n        if (!any(is.na(y.tilde.bis))) {\n",
        "            if (type == \"Huber\") {\n                mu.ini <- median(y.tilde.bis)\n                alpha <- .C(\"huber_pos\", as.integer(n.miss), \n                  as.double(y.tilde.bis), as.double(mu.ini), \n                  as.double(epsilon), as.double(sigma.hat), as.double(prob), \n                  as.double(k.h), as.integer(max.it), salida = as.double(0), \n                  PACKAGE = \"RBF\")$salida\n            }\n            if (type == \"Tukey\") {\n                mu.ini <- median(y.tilde.bis)\n                mu.ini <- .C(\"huber_pos\", as.integer(n.miss), \n",
        "                  as.double(y.tilde.bis), as.double(mu.ini), \n                  as.double(epsilon), as.double(sigma.hat), as.double(prob), \n                  as.double(k.h), as.integer(max.it), salida = as.double(0), \n                  PACKAGE = \"RBF\")$salida\n                alpha <- .C(\"tukey_pos\", as.integer(n.miss), \n                  as.double(y.tilde.bis), as.double(mu.ini), \n                  as.double(epsilon), as.double(sigma.hat), as.double(prob), \n                  as.double(k.t), as.integer(max.it), salida = as.double(0), \n",
        "                  PACKAGE = \"RBF\")$salida\n            }\n        }\n        else {\n            stop(\"Error computing additive components\")\n            (break)()\n        }\n    }\n    prediccion <- NULL\n    if (!is.null(point)) {\n        if (is.null(dim(point))) {\n            if (q == 1) {\n                prediccion <- mpunto <- as.matrix(point)\n            }\n            else {\n                prediccion <- mpunto <- t(as.matrix(point))\n            }\n        }\n        else {\n            prediccion <- mpunto <- point\n",
        "        }\n        np <- dim(mpunto)[1]\n        for (k in 1:np) {\n            for (j in 1:q) {\n                y.tilde.bis <- yp - alpha - rowSums(g.matriz[, \n                  -j, drop = FALSE])\n                if (degree == 0) {\n                  mu.ini <- median(y.tilde.bis[abs(Xp[, j] - \n                    mpunto[k, j]) < windows[j]])\n                  if (!is.na(mu.ini)) {\n                    if (type == \"Huber\") {\n                      prediccion[k, j] <- .C(\"kernel_huber_pos\", \n                        as.double(mpunto[k, j]), as.double(Xp[, \n",
        "                          j]), as.integer(n.miss), as.double(y.tilde.bis), \n                        as.double(mu.ini), as.double(windows[j]), \n                        as.double(epsilon), as.double(sigma.hat), \n                        as.double(prob), as.double(k.h), as.integer(max.it), \n                        salida = as.double(0), PACKAGE = \"RBF\")$salida\n                    }\n                    if (type == \"Tukey\") {\n                      prediccion[k, j] <- .C(\"kernel_tukey_pos\", \n                        as.double(mpunto[k, j]), as.double(as.matrix(Xp[, \n",
        "                          j])), as.integer(n.miss), as.double(y.tilde.bis), \n                        as.double(mu.ini), as.double(windows[j]), \n                        as.double(epsilon), as.double(sigma.hat), \n                        as.double(prob), as.double(k.t), as.integer(max.it), \n                        salida = as.double(0), PACKAGE = \"RBF\")$salida\n                    }\n                  }\n                  else {\n                    prediccion[k, j] <- NA\n                  }\n                }\n                if (degree > 0) {\n",
        "                  tmp <- outer(as.vector(Xp[, j] - mpunto[k, \n                    j]), 1:degree, \"^\")\n                  tmp <- cbind(rep(1, n.miss), tmp)\n                  beta.ini <- rep(0, degree + 1)\n                  if (type == \"Huber\") {\n                    prediccion[k, j] <- .C(\"kernel_huber_lin\", \n                      as.double(mpunto[k, j]), as.double(Xp[, \n                        j]), as.integer(n.miss), as.double(y.tilde.bis), \n                      as.double(tmp), as.integer(degree), as.double(beta.ini), \n",
        "                      as.double(windows[j]), as.double(epsilon), \n                      as.double(sigma.hat), as.double(prob), \n                      as.double(k.h), as.integer(max.it), salida = as.double(rep(0, \n                        degree + 1)), PACKAGE = \"RBF\")$salida[1]\n                  }\n                  if (type == \"Tukey\") {\n                    beta.ini <- .C(\"kernel_huber_lin\", as.double(mpunto[k, \n                      j]), as.double(Xp[, j]), as.integer(n.miss), \n                      as.double(y.tilde.bis), as.double(tmp), \n",
        "                      as.integer(degree), as.double(beta.ini), \n                      as.double(windows[j]), as.double(epsilon), \n                      as.double(sigma.hat), as.double(prob), \n                      as.double(k.h), as.integer(max.it), salida = as.double(rep(0, \n                        degree + 1)), PACKAGE = \"RBF\")$salida\n                    if (!any(is.na(beta.ini))) {\n                      prediccion[k, j] <- .C(\"kernel_tukey_lin\", \n                        as.double(mpunto[k, j]), as.double(Xp[, \n",
        "                          j]), as.integer(n.miss), as.double(y.tilde.bis), \n                        as.double(tmp), as.integer(degree), as.double(beta.ini), \n                        as.double(windows[j]), as.double(epsilon), \n                        as.double(sigma.hat), as.double(prob), \n                        as.double(k.t), as.integer(max.it), salida = as.double(rep(0, \n                          degree + 1)), PACKAGE = \"RBF\")$salida[1]\n                    }\n                    else {\n                      prediccion[k, j] <- NA\n",
        "                    }\n                  }\n                }\n            }\n        }\n    }\n    object <- list(alpha = alpha, g.matrix = g.matriz, sigma.hat = sigma.hat, \n        prediction = prediccion, type = type, Xp = Xp, yp = yp, \n        formula = formula)\n    class(object) <- c(\"backf.rob\", \"backf\", \"list\")\n    return(object)\n}\n<bytecode: 0x55777cb826f8>\n<environment: namespace:RBF>\n",
        "> ",
        "backf.cl",
        "function (formula, data, subset, point = NULL, windows, epsilon = 1e-06, \n    degree = 0, prob = NULL, max.it = 100) \n{\n    cl <- match.call()\n    mf <- match.call(expand.dots = FALSE)\n    m <- match(c(\"formula\", \"data\", \"subset\"), names(mf), 0)\n    mf <- mf[c(1, m)]\n    mf$drop.unused.levels <- TRUE\n    mf[[1]] <- as.name(\"model.frame\")\n    mf <- eval(mf, parent.frame())\n    mt <- attr(mf, \"terms\")\n    yp <- model.response(mf, \"numeric\")\n    Xp <- model.matrix(mt, mf, NULL)\n    if (all(Xp[, 1] == 1)) \n        Xp <- Xp[, -1]\n",
        "    n <- length(yp)\n    Xp <- as.matrix(Xp)\n    q <- dim(Xp)[2]\n    corte <- 10 * epsilon\n    corte.bis <- 10 * epsilon\n    yp <- yp[tmp <- (!is.na(yp))]\n    Xp <- Xp[tmp, , drop = FALSE]\n    n.miss <- length(yp)\n    if (is.null(prob)) {\n        prob <- rep(1, n.miss)\n    }\n    else {\n        prob <- prob[tmp]\n    }\n    alpha <- mean(yp)\n    g.matriz <- matrix(0, n.miss, q)\n    it <- 0\n    while ((corte > epsilon) & (it < max.it)) {\n        g.matriz.aux <- g.matriz\n        for (j in 1:q) {\n            y.tilde.bis <- yp - alpha - rowSums(g.matriz[, -j, \n",
        "                drop = FALSE])\n            for (i in 1:n.miss) {\n                we <- k.epan((Xp[, j] - Xp[i, j])/windows[j])\n                if (degree == 0) \n                  g.matriz[i, j] <- sum(we * y.tilde.bis)/sum(we)\n                if (degree > 0) {\n                  tmp <- outer(as.vector(Xp[, j] - Xp[i, j]), \n                    1:degree, \"^\")\n                  tmp <- cbind(rep(1, n.miss), tmp)\n                  g.matriz[i, j] <- solve(t(tmp * we) %*% tmp, \n                    t(tmp) %*% (we * y.tilde.bis))[1]\n",
        "                }\n            }\n        }\n        aux1 <- sum(colMeans(g.matriz))\n        g.matriz <- scale(g.matriz, center = TRUE, scale = FALSE)\n        corte <- my.norm.2(rowSums(g.matriz.aux) - rowSums(g.matriz))\n        it <- it + 1\n    }\n    prediccion <- NULL\n    if (!is.null(point)) {\n        if (is.null(dim(point))) {\n            if (q == 1) {\n                prediccion <- mpunto <- as.matrix(point)\n            }\n            else {\n                prediccion <- mpunto <- t(as.matrix(point))\n            }\n",
        "        }\n        else {\n            prediccion <- mpunto <- point\n        }\n        np <- dim(mpunto)[1]\n        for (k in 1:np) {\n            for (j in 1:q) {\n                y.tilde.bis <- yp - alpha - rowSums(g.matriz[, \n                  -j, drop = FALSE])\n                we <- k.epan((Xp[, j] - mpunto[k, j])/windows[j])\n                if (degree == 0) \n                  prediccion[k, j] <- sum(we * y.tilde.bis)/sum(we)\n                if (degree > 0) {\n                  tmp <- outer(as.vector(Xp[, j] - mpunto[k, \n",
        "                    j]), 1:degree, \"^\")\n                  tmp <- cbind(rep(1, n.miss), tmp)\n                  prediccion[k, j] <- solve(t(tmp * we) %*% tmp, \n                    t(tmp) %*% (we * y.tilde.bis))[1]\n                }\n            }\n        }\n    }\n    object <- list(alpha = alpha, g.matrix = g.matriz, prediction = prediccion, \n        Xp = Xp, yp = yp, formula = formula)\n    class(object) <- c(\"backf.cl\", \"backf\", \"list\")\n    return(object)\n}\n<bytecode: 0x55777cc21870>\n<environment: namespace:RBF>\n",
        "> ",
        "# Upload the data",
        "> ",
        "datos <- read.csv(\"/home/alejandra/Dropbox/Paper de paquetes en R/JOSS/pisasci2006.csv\", header=TRUE)",
        "> ",
        "str(datos)",
        "'data.frame':\t65 obs. of  11 variables:\n $ Country : Factor w/ 65 levels \"Albania\",\"Argentina\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ Overall : int  NA 391 527 511 382 510 390 434 534 438 ...\n $ Issues  : int  NA 395 535 505 353 515 398 427 532 444 ...\n $ Explain : int  NA 386 520 516 412 503 390 444 531 432 ...\n $ Evidence: int  NA 385 531 505 344 516 378 417 542 440 ...\n $ Interest: int  NA 567 465 507 612 503 592 523 469 591 ...\n $ Support : int  NA 506 487 515 542 492 519 527 501 564 ...\n $ Income  : num  0.599 0.678 0.826 0.835 0.566 0.831 0.637 0.663 0.84 0.673",
        " ...\n $ Health  : num  0.886 0.868 0.965 0.944 0.78 0.935 0.818 0.829 0.951 0.923 ...\n $ Edu     : num  0.716 0.786 0.978 0.824 NA 0.868 0.646 0.778 0.902 0.764 ...\n $ HDI     : num  0.724 0.773 0.92 0.866 NA 0.877 0.695 0.753 0.897 0.78 ...\n",
        "> ",
        "# Complete cases",
        "> ",
        "ccs <- complete.cases(datos)",
        "> ",
        "X <- as.matrix( datos[ccs, c('Income', 'Edu')] )",
        "> ",
        "y <- as.vector( datos[ccs, 'Overall'] )",
        "> ",
        "#Load packages",
        "> ",
        "library(RobStatTM)",
        "> ",
        "install_github(\"msalibian/RBF\", force=TRUE)",
        "Downloading GitHub repo msalibian/RBF@master\n",
        "  \r   checking for file ‘/tmp/RtmppDcxiH/remotes3a3f36b92a98/msalibian-RBF-f308e17/DESCRIPTION’ ...\r  \r\u001B[32m✓\u001B[39m  \u001B[38;5;247mchecking for file ‘/tmp/RtmppDcxiH/remotes3a3f36b92a98/msalibian-RBF-f308e17/DESCRIPTION’\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mpreparing ‘RBF’:\u001B[39m\u001B[36m\u001B[39m\n\r  \r   checking DESCRIPTION meta-information ...\r  \r\u001B[32m✓\u001B[39m  \u001B[38;5;247mchecking DESCRIPTION meta-information\u001B[39m\u001B[36m\u001B[39m\n\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mcleaning src\u001B[39m\u001B[36m\u001B[39m",
        "\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mchecking for LF line-endings in source and make files and shell scripts\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mchecking for empty or unneeded directories\u001B[39m\u001B[36m\u001B[39m\n\r  \r\u001B[38;5;247m─\u001B[39m\u001B[38;5;247m  \u001B[39m\u001B[38;5;247mbuilding ‘RBF_2.0.1.tar.gz’\u001B[39m\u001B[36m\u001B[39m\n\r  \r   \n\r",
        "Installing package into ‘/home/alejandra/R/x86_64-pc-linux-gnu-library/3.6’\n(as ‘lib’ is unspecified)\n",
        "* installing *source* package ‘RBF’ ...\n",
        "** using staged installation\n",
        "** libs\n",
        "gcc -std=gnu99 -I\"/usr/share/R/include\" -DNDEBUG     -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-jbaK_j/r-base-3.6.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c RBF-fn.c -o RBF-fn.o\ngcc -std=gnu99 -I\"/usr/share/R/include\" -DNDEBUG     -fpic  -g -O2 -fdebug-prefix-map=/build/r-base-jbaK_j/r-base-3.6.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c init.c -o init.o\ngcc -std=gnu99 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o RBF.so RBF-fn.o init.o -L/usr/lib/R/lib -lR\n",
        "installing to /home/alejandra/R/x86_64-pc-linux-gnu-library/3.6/00LOCK-RBF/00new/RBF/libs\n",
        "** R\n",
        "** byte-compile and prepare package for lazy loading\n",
        "** help\n",
        "*** installing help indices\n",
        "** building package indices\n",
        "** testing if installed package can be loaded from temporary location\n",
        "** checking absolute paths in shared objects and dynamic libraries\n",
        "** testing if installed package can be loaded from final location\n",
        "** testing if installed package keeps a record of temporary installation path\n",
        "* DONE (RBF)\n",
        "> ",
        "library(RBF)",
        "> ",
        "# Scatter plot",
        "> ",
        "pairs(cbind(y, X))",
        "> ",
        "# Robust fit",
        "> ",
        "# Bandwidth selection with robust leave-one-out cross-validation",
        "> ",
        "a <- c(0.5, 1, 1.5, 2)",
        "> ",
        "h1 <- a * sd(X[,1])",
        "> ",
        "# Classical fit",
        "> ",
        "# Bandwidth selection with leave-one-out cross-validation",
        "> ",
        "a <- c(0.5, 1, 1.5, 2)",
        "> ",
        "h1 <- a * sd(X[,1])",
        "> ",
        "h2 <- a * sd(X[,2])",
        "> ",
        "hh <- expand.grid(h1, h2)",
        "> ",
        "nh <- nrow(hh)",
        "> ",
        "rmspe <- rep(NA, nh)",
        "> ",
        "jbest <- 0",
        "> ",
        "cvbest <- +Inf",
        "> ",
        "# leave-one-out",
        "> ",
        "n <- nrow(X)",
        "> ",
        "system.time({",
        "+ ",
        "  for(i in 1:nh) {",
        "+ ",
        "    # leave-one-out CV loop",
        "+ ",
        "    print(hh[i,])",
        "+ ",
        "    preds <- rep(NA, n)",
        "+ ",
        "    for(j in 1:n) {",
        "+ ",
        "      print(j)",
        "+ ",
        "      tmp <- try( backf.cl(y ~ X, point = X[j, ],",
        "+ ",
        "                            windows = hh[i, ], epsilon = 1e-06, max.it = 100,",
        "+ ",
        "                            subset = c(-j) ))",
        "+ ",
        "      if (class(tmp)[1] != \"try-error\") {",
        "+ ",
        "        preds[j] <- rowSums(tmp$prediction) + tmp$alpha",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    pred.res <- preds - y",
        "+ ",
        "    print(sum(is.na(pred.res)))",
        "+ ",
        "    ",
        "+ ",
        "    if(sum(!is.na(pred.res))>0){",
        "+ ",
        "      rmspe[i] <- mean(pred.res^2, na.rm=TRUE)",
        "+ ",
        "      if( rmspe[i] < cvbest ) {",
        "+ ",
        "        jbest <- i",
        "+ ",
        "        cvbest <- rmspe[i]",
        "+ ",
        "        print('Record')",
        "+ ",
        "      }",
        "+ ",
        "    }",
        "+ ",
        "    print(c(i, rmspe[i]))",
        "+ ",
        "  }",
        "+ ",
        "})",
        "        Var1       Var2\n1 0.05384702 0.05629671\n[1] 1\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 2\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 3\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 4\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 5\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 6\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 7\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 8\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 9\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 10\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 11\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 12\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 13\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 14\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 15\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 16\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 17\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 18\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 19\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 20\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 21\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 22\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 23\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 24\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 25\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 26\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 27\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 28\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 29\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 30\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 31\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 32\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 33\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 34\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 35\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 36\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 37\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 38\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 39\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 40\n",
        "Error in while ((corte > epsilon) & (it < max.it)) { : \n  valor ausente donde TRUE/FALSE es necesario\n",
        "[1] 41\n",
        "\n",
        "Timing stopped at: 3.874 0.004 3.863\n",
        "Error in fetch(key) : \n  lazy-load database '/home/alejandra/R/x86_64-pc-linux-gnu-library/3.6/RBF/help/RBF.rdb' is corrupt\n",
        "> ",
        "backf.",
        "Error: objeto 'backf.' no encontrado\n",
        "> ",
        "backf.ck",
        "Error: objeto 'backf.ck' no encontrado\n",
        "> ",
        "backf.cl",
        "function (formula, data, subset, point = NULL, windows, epsilon = 1e-06, \n    degree = 0, prob = NULL, max.it = 100) \n{\n    cl <- match.call()\n    mf <- match.call(expand.dots = FALSE)\n    m <- match(c(\"formula\", \"data\", \"subset\"), names(mf), 0)\n    mf <- mf[c(1, m)]\n    mf$drop.unused.levels <- TRUE\n    mf[[1]] <- as.name(\"model.frame\")\n    mf <- eval(mf, parent.frame())\n    mt <- attr(mf, \"terms\")\n    yp <- model.response(mf, \"numeric\")\n    Xp <- model.matrix(mt, mf, NULL)\n    if (all(Xp[, 1] == 1)) \n        Xp <- Xp[, -1]\n",
        "    n <- length(yp)\n    Xp <- as.matrix(Xp)\n    q <- dim(Xp)[2]\n    corte <- 10 * epsilon\n    corte.bis <- 10 * epsilon\n    yp <- yp[tmp <- (!is.na(yp))]\n    Xp <- Xp[tmp, , drop = FALSE]\n    n.miss <- length(yp)\n    if (is.null(prob)) {\n        prob <- rep(1, n.miss)\n    }\n    else {\n        prob <- prob[tmp]\n    }\n    alpha <- mean(yp)\n    g.matriz <- matrix(0, n.miss, q)\n    it <- 0\n    while ((corte > epsilon) & (it < max.it)) {\n        g.matriz.aux <- g.matriz\n        for (j in 1:q) {\n            y.tilde.bis <- yp - alpha - rowSums(g.matriz[, -j, \n",
        "                drop = FALSE])\n            for (i in 1:n.miss) {\n                we <- k.epan((Xp[, j] - Xp[i, j])/windows[j])\n                if (degree == 0) \n                  g.matriz[i, j] <- sum(we * y.tilde.bis)/sum(we)\n                if (degree > 0) {\n                  tmp <- outer(as.vector(Xp[, j] - Xp[i, j]), \n                    1:degree, \"^\")\n                  tmp <- cbind(rep(1, n.miss), tmp)\n                  g.matriz[i, j] <- solve(t(tmp * we) %*% tmp, \n                    t(tmp) %*% (we * y.tilde.bis))[1]\n",
        "                }\n            }\n        }\n        aux1 <- sum(colMeans(g.matriz))\n        g.matriz <- scale(g.matriz, center = TRUE, scale = FALSE)\n        corte <- my.norm.2(rowSums(g.matriz.aux) - rowSums(g.matriz))\n        it <- it + 1\n    }\n    prediccion <- NULL\n    if (!is.null(point)) {\n        if (is.null(dim(point))) {\n            if (q == 1) {\n                prediccion <- mpunto <- as.matrix(point)\n            }\n            else {\n                prediccion <- mpunto <- t(as.matrix(point))\n            }\n",
        "        }\n        else {\n            prediccion <- mpunto <- point\n        }\n        np <- dim(mpunto)[1]\n        for (k in 1:np) {\n            for (j in 1:q) {\n                y.tilde.bis <- yp - alpha - rowSums(g.matriz[, \n                  -j, drop = FALSE])\n                we <- k.epan((Xp[, j] - mpunto[k, j])/windows[j])\n                if (degree == 0) \n                  prediccion[k, j] <- sum(we * y.tilde.bis)/sum(we)\n                if (degree > 0) {\n                  tmp <- outer(as.vector(Xp[, j] - mpunto[k, \n",
        "                    j]), 1:degree, \"^\")\n                  tmp <- cbind(rep(1, n.miss), tmp)\n                  prediccion[k, j] <- solve(t(tmp * we) %*% tmp, \n                    t(tmp) %*% (we * y.tilde.bis))[1]\n                }\n            }\n        }\n    }\n    object <- list(alpha = alpha, g.matrix = g.matriz, prediction = prediccion, \n        Xp = Xp, yp = yp, formula = formula)\n    class(object) <- c(\"backf.cl\", \"backf\", \"list\")\n    return(object)\n}\n<bytecode: 0x55777cc21870>\n<environment: namespace:RBF>\n",
        "\nRestarting R session...\n\n"
    ]
}