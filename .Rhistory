Xp[ids==j,],
j <- 1
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
tmp
if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
}
class(tmp)
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(pred.res, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 4.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.2, 0.4, 0.6, 0.8, 1)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
Sys.time({
for(i in 1:nh){
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(pred.res, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
sal
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 4.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.2, 0.4, 0.6, 0.8, 1)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 4.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.1, 0.2, 0.4, 0.6, 0.8, 1, 1.2)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
i0 <- which.min(rmspe)
bandw <- hh[i0,]
bandw
i0
bandw
rmspe
i <- 1
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(preds, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
rmspe[i]
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 4.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.1, 0.2, 0.4, 0.6, 0.8, 1, 1.2)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
i0
rmspe
knitr::opts_chunk$set(echo = TRUE)
function.g1 <- function(x1) 24*(x1-1/2)^2-(6/5)
function.g2 <- function(x2) 2*pi*sin(pi*x2)-(48/(pi^2))
set.seed(140)
n <- 500
x1 <- runif(n)
x2 <- runif(n)
X <- cbind(x1, x2)
eps <- rnorm(n,0,sd=0.15)
regression <- function.g1(x1)+function.g2(x2)
y <- regression + eps
bandw <- c(0.1444177, 0.1449206)
library(RBF)
point <- c(0.7, 0.6)
robust.fit <- backf.rob(y ~ X, point=point, windows=bandw, type = 'Tukey', degree=1)
robust.fit$prediction
c(function.g1(point[1]), function.g2(point[2]))
lim.rob <- matrix(0, 2, 2)
functions.g <- cbind(function.g1(X[,1]), function.g2(X[,2]))
par(mfrow=c(1,2))
for(j in 1:2) {
res <- y - robust.fit$alpha - robust.fit$g.matrix[,-j]
lim.rob[,j] <- range(res)
plot(X[,j], res, type='p', pch=19, col='gray45', xlab=colnames(X)[j], ylab='', cex=1, ylim=lim.rob[,j])
ord <- order(X[,j])
lines(X[ord,j], robust.fit$g.matrix[ord,j], lwd=3, col='blue')
lines(X[ord,j], functions.g[ord,j], lwd=3)
}
eps <- rnorm(n,0,sd=0.15)
prop.cont <- 0.10
ou <- rbinom(n, size=1, prob=prop.cont)
eps.ou <- eps
eps.ou[ ou == 1 ] <- rnorm(sum(ou),mean=15, sd=0.1)
yout <- regression + eps.ou
bandw <- c(0.5, 0.5)
robust.fit.out <- backf.rob(yout ~ X, point=point, windows=bandw, type = 'Tukey', degree=1)
robust.fit.out$prediction
c(function.g1(point[1]), function.g2(point[2]))
lim.rob <- matrix(0, 2, 2)
functions.g <- cbind(function.g1(X[,1]), function.g2(X[,2]))
par(mfrow=c(1,2))
for(j in 1:2) {
res <- y - robust.fit.out$alpha - robust.fit.out$g.matrix[,-j]
lim.rob[,j] <- range(res)
plot(X[,j], res, type='p', pch=19, col='gray45', xlab=colnames(X)[j], ylab='', cex=1, ylim=lim.rob[,j])
ord <- order(X[,j])
lines(X[ord,j], robust.fit.out$g.matrix[ord,j], lwd=3, col='blue')
lines(X[ord,j], functions.g[ord,j], lwd=3)
}
function.g1 <- function(x1) 24*(x1-1/2)^2-(6/5)
function.g2 <- function(x2) 2*pi*sin(pi*x2)-(48/(pi^2))
set.seed(140)
n <- 500
x1 <- runif(n)
x2 <- runif(n)
X <- cbind(x1, x2)
eps <- rnorm(n,0,sd=0.15)
regression <- function.g1(x1)+function.g2(x2)
y <- regression + eps
plot(x1,y-function.g2(x2))
lines(function.g1)
lines(sort(x1),function.g1(sort(x1)))
eps <- rnorm(n,0,sd=0.15)
prop.cont <- 0.10
ou <- rbinom(n, size=1, prob=prop.cont)
eps.ou <- eps
eps.ou[ ou == 1 ] <- rnorm(sum(ou),mean=15, sd=0.1)
yout <- regression + eps.ou
plot(x1,yout-function.g2(x2))
lines(sort(x1),function.g1(sort(x1)))
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(preds, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.8, 1, 1.2, 1.5)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
bandw <- hh[i0,]
bandw
i0
rmspe
sd(X[,1])
X[,1]
plot(X[,1])
hist(X[,1])
sd(X[,1])
2.5*sd(X[,1])
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(1, 1.5, 2, 2.5)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
i0
yp
y
yp <- y
k <- 5
n
floor(n/k)
knitr::opts_chunk$set(echo = TRUE)
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yy ~ XX, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(preds, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.25, 0.5, 0.75, 1)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
knitr::opts_chunk$set(echo = TRUE)
function.g1 <- function(x1) 24*(x1-1/2)^2-(6/5)
function.g2 <- function(x2) 2*pi*sin(pi*x2)-(48/(pi^2))
set.seed(140)
n <- 500
x1 <- runif(n)
x2 <- runif(n)
X <- cbind(x1, x2)
eps <- rnorm(n,0,sd=0.15)
regression <- function.g1(x1)+function.g2(x2)
y <- regression + eps
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yy ~ XX, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(preds, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.25, 0.5, 0.75, 1)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
library(RBF)
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.25, 0.5, 0.75, 1)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
bandw <- hh[i0,]
bandw
i0
rmspe
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.75, 1, 1.25, 1.5)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yy ~ XX, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(preds, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 9.5 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
a <- c(0.75, 1, 1.25, 1.5)
h1 <- a * sd(X[,1])
h2 <- a * sd(X[,2])
hh <- expand.grid(h1, h2)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
bandw <- hh[i0,]
bandw
i0
bandw
knitr::opts_chunk$set(echo = TRUE)
backf.rob.cv <- function(k=5, Xp, yp, windows,
degree, type) {
n <- length(yp)
k1 <- floor(n/k)
ids <- rep(1:k, each=k1)
if( length(ids) < n ) ids <- c(ids, 1:(n%%k))
ids <- sample(ids)
preds <- rep(NA, n)
for(j in 1:k) {
XX <- Xp[ids!=j,]
yy <- yp[ids!=j]
tmp <- backf.rob(yy ~ XX, point=Xp[ids==j,], windows=windows, degree=degree, type=type) #try( backf.rob(yp ~ Xp, point=Xp[ids==j,], windows=windows, degree=degree, type=type) )
#if( class(tmp) != 'try-error') {
preds[ids==j] <- rowSums(tmp$prediction) + tmp$alpha
#}
}
tmp.re <- RobStatTM::locScaleM(preds, na.rm=TRUE)
sal <- tmp.re$mu^2 + tmp.re$disper^2
return(sal)
}
function.g1 <- function(x1) 24*(x1-1/2)^2-(6/5)
function.g2 <- function(x2) 2*pi*sin(pi*x2)-(48/(pi^2))
set.seed(140)
n <- 500
x1 <- runif(n)
x2 <- runif(n)
X <- cbind(x1, x2)
eps <- rnorm(n,0,sd=0.15)
regression <- function.g1(x1)+function.g2(x2)
y <- regression + eps
library(RBF)
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 2 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
h1 <- c(0.1, 0.15, 0.2, 0.25)
hh <- expand.grid(h1, h1)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
bandw <- hh[i0,]
bandw
i0
rmspe
# Bandwidth selection with leave-one-out cross-validation
# This takes some time to compute (approx 2 minutes running
# R 3.6.3 on an Intel(R) Core(TM) i7-10900 CPU @ 2.90GHz)
h1 <- c(0.2, 0.25, 0.30, 0.35)
hh <- expand.grid(h1, h1)
nh <- nrow(hh)
rmspe <- rep(NA, nh)
system.time({
for(i in 1:nh){
print(i)
rmspe[i] <- backf.rob.cv(k=5, Xp=X, yp=y, windows=hh[i,], degree=1, type='Tukey')
}
})
i0 <- which.min(rmspe)
bandw <- hh[i0,]
bandw
rmspe
i0
